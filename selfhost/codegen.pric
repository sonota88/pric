# -*- mode: ruby -*-

#include lib/std.pric
#include lib/words.pric
#include lib/types.pric
#include lib/json.pric

# --------------------------------

def asm_indent()
  putchar(C_SPC());
  putchar(C_SPC());
end

def asm_exit()
  var [5]s_temp;

  aset(&s_temp, 0, 101); # e
  aset(&s_temp, 1, 120); # x
  aset(&s_temp, 2, 105); # i
  aset(&s_temp, 3, 116); # t
  aset(&s_temp, 4,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_LF());
end

def asm_label(label_)
  var [6]s_temp;

  aset(&s_temp, 0, 108); # l
  aset(&s_temp, 1,  97); # a
  aset(&s_temp, 2,  98); # b
  aset(&s_temp, 3, 101); # e
  aset(&s_temp, 4, 108); # l
  aset(&s_temp, 5,   0);

  print_s(&s_temp);
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_call(label_)
  var [5]s_temp;

  aset(&s_temp, 0,  99); # c
  aset(&s_temp, 1,  97); # a
  aset(&s_temp, 2, 108); # l
  aset(&s_temp, 3, 108); # l
  aset(&s_temp, 4,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_ret()
  var [4]s_temp;

  aset(&s_temp, 0, 114); # r
  aset(&s_temp, 1, 101); # e
  aset(&s_temp, 2, 116); # t
  aset(&s_temp, 3,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_LF());
end

def asm_cp(src_, dest_)
  var [3]s_temp;

  aset(&s_temp, 0,  99); # c
  aset(&s_temp, 1, 112); # p
  aset(&s_temp, 2,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_s(src_);
  putchar(C_SPC());
  print_s(dest_);
  putchar(C_LF());
end

def asm_push(arg_)
  var [5]s_temp;

  aset(&s_temp, 0, 112); # p
  aset(&s_temp, 1, 117); # u
  aset(&s_temp, 2, 115); # s
  aset(&s_temp, 3, 104); # h
  aset(&s_temp, 4,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_s(arg_);
  putchar(C_LF());
end

def asm_pop(dest_)
  var [4]s_temp;

  aset(&s_temp, 0, 112); # p
  aset(&s_temp, 1, 111); # o
  aset(&s_temp, 2, 112); # p
  aset(&s_temp, 3,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_s(dest_);
  putchar(C_LF());
end

def asm_sub_sp(n)
  var [7]s_temp;

  aset(&s_temp, 0, 115); # s
  aset(&s_temp, 1, 117); # u
  aset(&s_temp, 2,  98); # b
  aset(&s_temp, 3,  95); # _
  aset(&s_temp, 4, 115); # s
  aset(&s_temp, 5, 112); # p
  aset(&s_temp, 6,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_i(n);
  putchar(C_LF());
end

def asm_add_sp(n)
  var [7]s_temp;

  aset(&s_temp, 0,  97); # a
  aset(&s_temp, 1, 100); # d
  aset(&s_temp, 2, 100); # d
  aset(&s_temp, 3,  95); # _
  aset(&s_temp, 4, 115); # s
  aset(&s_temp, 5, 112); # p
  aset(&s_temp, 6,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_i(n);
  putchar(C_LF());
end

def asm_compare()
  asm_indent();
  putchar( 99); # c
  putchar(111); # o
  putchar(109); # m
  putchar(112); # p
  putchar( 97); # a
  putchar(114); # r
  putchar(101); # e
  putchar(C_LF());
end

def asm_jump(label_)
  asm_indent();
  putchar(106); # j
  putchar(117); # u
  putchar(109); # m
  putchar(112); # p
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_jump_eq(label_)
  asm_indent();
  putchar(106); # j
  putchar(117); # u
  putchar(109); # m
  putchar(112); # p
  putchar( 95); # _
  putchar(101); # e
  putchar(113); # q
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_vm_comment(vm_comment_)
  var [5] str__cmt; str_set__cmt(&str__cmt);
  var vm_comment_size = 40; var [40]vm_comment;
  var i;
  var c;

  str_cp_with_check(
    &vm_comment, vm_comment_,
    vm_comment_size
  );

  i = 0;
  while (i < str_size(&vm_comment))
    c = char_at(&vm_comment, i);
    if (c == C_SPC())
      c = 126; # ~
      aset(&vm_comment, i, c);
    end
    i = i + 1;
  end

  asm_indent();
  print_s(&str__cmt);
  putchar(C_SPC());
  print_s(&vm_comment);
  putchar(C_LF());
end

def asm_get_vram(vram_addr_, dest_)
  var [9]s_temp;

  aset(&s_temp, 0, 103); # g
  aset(&s_temp, 1, 101); # e
  aset(&s_temp, 2, 116); # t
  aset(&s_temp, 3,  95); # _
  aset(&s_temp, 4, 118); # v
  aset(&s_temp, 5, 114); # r
  aset(&s_temp, 6,  97); # a
  aset(&s_temp, 7, 109); # m
  aset(&s_temp, 8,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_s(vram_addr_);
  putchar(C_SPC());
  print_s(dest_);
  putchar(C_LF());
end

def asm_set_vram(vram_addr_, val_)
  var [9]s_temp;

  aset(&s_temp, 0, 115); # s
  aset(&s_temp, 1, 101); # e
  aset(&s_temp, 2, 116); # t
  aset(&s_temp, 3,  95); # _
  aset(&s_temp, 4, 118); # v
  aset(&s_temp, 5, 114); # r
  aset(&s_temp, 6,  97); # a
  aset(&s_temp, 7, 109); # m
  aset(&s_temp, 8,   0);

  asm_indent();
  print_s(&s_temp);
  putchar(C_SPC());
  print_s(vram_addr_);
  putchar(C_SPC());
  print_s(val_);
  putchar(C_LF());
end

def asm_fn_prologue()
  var [3]s_bp; str_set_bp(&s_bp);
  var [3]s_sp; str_set_sp(&s_sp);

  asm_push(&s_bp);
  asm_cp(&s_sp, &s_bp);
end

def asm_fn_epilogue()
  var [3]s_bp; str_set_bp(&s_bp);
  var [3]s_sp; str_set_sp(&s_sp);

  asm_cp(&s_bp, &s_sp);
  asm_pop(&s_bp);
end

# --------------------------------

def to_fn_arg_addr(dest_, names_, name_)
  var idx = Names_index(names_, name_);

  aset(dest_, 0,  91); # [
  aset(dest_, 1,  98); # b
  aset(dest_, 2, 112); # p
  aset(dest_, 3,  58); # :

  if ((idx + 1) < 10)
    aset(dest_, 4, i_to_c(idx + 2));
  else
    panic(230); # to_fn_arg_addr: not yet supported
  end

  aset(dest_, 5,  93); # ]
  aset(dest_, 6,   0);
end

def to_lvar_addr(dest_, names_, name_)
  var idx = Names_index(names_, name_);

  aset(dest_, 0,  91); # [
  aset(dest_, 1,  98); # b
  aset(dest_, 2, 112); # p
  aset(dest_, 3,  58); # :
  aset(dest_, 4,  45); # -

  if ((idx + 1) < 10)
    aset(dest_, 5, i_to_c(idx + 1));
  else
    panic(181); # to_lvar_addr: not yet supported
  end

  aset(dest_, 6,  93); # ]
  aset(dest_, 7,   0);
end

def append_label_id(label_, id, dest_size)
  var [2]underscore;
  var [8]id_str;

  aset(&underscore, 0, 95); # _
  aset(&underscore, 1,  0);
  str_append_with_check(label_, &underscore, dest_size);

  unparse_int(&id_str, id);
  str_append_with_check(label_, &id_str, dest_size);
end

def match_vram(str_)
  var [6]pattern;
  var [6]s_temp;
  var i;

  aset(&pattern, 0, 118); # v
  aset(&pattern, 1, 114); # r
  aset(&pattern, 2,  97); # a
  aset(&pattern, 3, 109); # m
  aset(&pattern, 4,  91); # [
  aset(&pattern, 5,   0);

  substr_with_check(&s_temp, str_, 0, 5, 6);

  if (str_eq(&s_temp, &pattern))
    i = char_index(str_, 93, 0); # ]
    return __sub(i, 5);
  else
    return 0;
  end
end

# --------------------------------

def gen_var(g_, fn_arg_names_, lvar_names_, stmt_)
  var set_stmt_;
  var [4]s_set; str_set_set(&s_set);

  asm_sub_sp(1);

  if (NodeList_size(stmt_) == 3)
    set_stmt_ = NodeList_new(g_);
    NodeList_add_str(g_, set_stmt_, &s_set);
    NodeList_add(set_stmt_, NodeList_get(stmt_, 1));
    NodeList_add(set_stmt_, NodeList_get(stmt_, 2));

    gen_set(g_, fn_arg_names_, lvar_names_, set_stmt_);
  end
end

def gen_case(g_, fn_arg_names_, lvar_names_, stmt_)
  var i;
  var when_clauses_;
  var when_clause_;
  var cond_expr_node_;
  var stmts_;
  var label_id;

  var label_size = 19; # end_when_xxxx_xxxx
  var [19]label_end;
  var [19]label_when_head;
  var [19]label_end_when_head;
  var [19]label_temp;

  var [2]s_1;
  var [6]s_reg_b; str_set_reg_b(&s_reg_b);
  var when_index = -1;

  aset(&s_1, 0, 49); # 1
  aset(&s_1, 1,  0);

  inc_label_id(g_);
  label_id = get_label_id(g_);

  aset(&label_end, 0, 101); # e
  aset(&label_end, 1, 110); # n
  aset(&label_end, 2, 100); # d
  aset(&label_end, 3,  95); # _
  aset(&label_end, 4,  99); # c
  aset(&label_end, 5,  97); # a
  aset(&label_end, 6, 115); # s
  aset(&label_end, 7, 101); # e
  aset(&label_end, 8,   0);
  append_label_id(&label_end, label_id, label_size);

  aset(&label_when_head, 0, 119); # w
  aset(&label_when_head, 1, 104); # h
  aset(&label_when_head, 2, 101); # e
  aset(&label_when_head, 3, 110); # n
  aset(&label_when_head, 4,   0);
  append_label_id(&label_when_head, label_id, label_size);

  aset(&label_end_when_head, 0, 101); # e
  aset(&label_end_when_head, 1, 110); # n
  aset(&label_end_when_head, 2, 100); # d
  aset(&label_end_when_head, 3,  95); # _
  aset(&label_end_when_head, 4, 119); # w
  aset(&label_end_when_head, 5, 104); # h
  aset(&label_end_when_head, 6, 101); # e
  aset(&label_end_when_head, 7, 110); # n
  aset(&label_end_when_head, 8,   0);
  append_label_id(&label_end_when_head, label_id, label_size);

  when_clauses_ = NodeList_rest(g_, stmt_, 1);

  i = 0;
  while (i < NodeList_size(when_clauses_))
    when_index = when_index + 1;
    when_clause_ = NodeList_get_as_list(when_clauses_, i);
    cond_expr_node_ = NodeList_get(when_clause_, 0);
    stmts_ = NodeList_rest(g_, when_clause_, 1);

    gen_expr(g_, fn_arg_names_, lvar_names_, cond_expr_node_);
    asm_cp(&s_1, &s_reg_b);
    asm_compare();

    # {label_when_head}_{when_index}
    str_cp(&label_temp, &label_when_head);
    append_label_id(&label_temp, when_index, label_size);
    asm_jump_eq(&label_temp);

    # {label_end_when_head}_{when_index}
    str_cp(&label_temp, &label_end_when_head);
    append_label_id(&label_temp, when_index, label_size);
    asm_jump(&label_temp);

    # {label_when_head}_{when_index}
    str_cp(&label_temp, &label_when_head);
    append_label_id(&label_temp, when_index, label_size);
    asm_label(&label_temp);

    gen_stmts(g_, fn_arg_names_, lvar_names_, stmts_);

    asm_jump(&label_end);

    # {label_end_when_head}_{when_index}
    str_cp(&label_temp, &label_end_when_head);
    append_label_id(&label_temp, when_index, label_size);
    asm_label(&label_temp);

    i = i + 1;
  end

  asm_label(&label_end);
end

def gen_while(g_, fn_arg_names_, lvar_names_, stmt_)
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [6]s_reg_b; str_set_reg_b(&s_reg_b);

  var [2]s_0;
  var [2]s_1;

  var label_begin_size = 11; var [11]label_begin; # while_xxxx
  var label_end_size = 15; var [15]label_end; # end_while_xxxx
  var label_true_size = 10; var [10]label_true; # true_xxxx

  var label_id;
  var cond_expr_node_ = NodeList_get(stmt_, 1);
  var stmts_ = NodeList_get_as_list(stmt_, 2);

  aset(&s_0, 0, 48); # 0
  aset(&s_0, 1,  0);

  aset(&s_1, 0, 49); # 1
  aset(&s_1, 1,  0);

  inc_label_id(g_);
  label_id = get_label_id(g_);

  aset(&label_begin, 0, 119); # w
  aset(&label_begin, 1, 104); # h
  aset(&label_begin, 2, 105); # i
  aset(&label_begin, 3, 108); # l
  aset(&label_begin, 4, 101); # e
  aset(&label_begin, 5,   0);
  append_label_id(&label_begin, label_id, label_begin_size);

  aset(&label_end,  0, 101); # e
  aset(&label_end,  1, 110); # n
  aset(&label_end,  2, 100); # d
  aset(&label_end,  3,  95); # _
  aset(&label_end,  4, 119); # w
  aset(&label_end,  5, 104); # h
  aset(&label_end,  6, 105); # i
  aset(&label_end,  7, 108); # l
  aset(&label_end,  8, 101); # e
  aset(&label_end, 9,   0);
  append_label_id(&label_end, label_id, label_end_size);

  aset(&label_true, 0, 116); # t
  aset(&label_true, 1, 114); # r
  aset(&label_true, 2, 117); # u
  aset(&label_true, 3, 101); # e
  aset(&label_true, 4,   0);
  append_label_id(&label_true, label_id, label_true_size);

  asm_label(&label_begin);

  gen_expr(g_, fn_arg_names_, lvar_names_, cond_expr_node_);

  asm_cp(&s_1, &s_reg_b);

  asm_compare();

  asm_jump_eq(&label_true);

  asm_jump(&label_end);


  asm_label(&label_true);
  gen_stmts(g_, fn_arg_names_, lvar_names_, stmts_);

  asm_jump(&label_begin);


  asm_label(&label_end);
end

def _gen_expr_add()
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [6]s_reg_b; str_set_reg_b(&s_reg_b);

  asm_pop(&s_reg_b);
  asm_pop(&s_reg_a);

  asm_indent();
  putchar( 97); # a
  putchar(100); # d
  putchar(100); # d
  putchar( 95); # _
  putchar( 97); # a
  putchar( 98); # b
  putchar(C_LF());
end

def _gen_expr_mult()
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [6]s_reg_b; str_set_reg_b(&s_reg_b);

  asm_pop(&s_reg_b);
  asm_pop(&s_reg_a);

  asm_indent();
  putchar(109); # m
  putchar(117); # u
  putchar(108); # l
  putchar(116); # t
  putchar( 95); # _
  putchar( 97); # a
  putchar( 98); # b
  putchar(C_LF());
end

def _gen_expr_eq(g_)
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [6]s_reg_b; str_set_reg_b(&s_reg_b);
  var [2]s_0;
  var [2]s_1;
  var label_end_size = 12; var [12]label_end; # end_eq_xxxx ... 11 chars + 1
  var label_then_size = 10; var [10]label_then; # then_xxxx ... 9 chars + 1
  var label_id;

  aset(&s_0, 0, 48); # 0
  aset(&s_0, 1,  0);

  aset(&s_1, 0, 49); # 1
  aset(&s_1, 1,  0);

  inc_label_id(g_);
  label_id = get_label_id(g_);

  aset(&label_end, 0, 101); # e
  aset(&label_end, 1, 110); # n
  aset(&label_end, 2, 100); # d
  aset(&label_end, 3,  95); # _
  aset(&label_end, 4, 101); # e
  aset(&label_end, 5, 113); # q
  aset(&label_end, 6,   0);
  append_label_id(&label_end, label_id, label_end_size);

  aset(&label_then, 0, 116); # t
  aset(&label_then, 1, 104); # h
  aset(&label_then, 2, 101); # e
  aset(&label_then, 3, 110); # n
  aset(&label_then, 4,   0);
  append_label_id(&label_then, label_id, label_then_size);

  asm_pop(&s_reg_b);
  asm_pop(&s_reg_a);

  asm_compare();

  asm_jump_eq(&label_then);

  asm_cp(&s_0, &s_reg_a);

  asm_jump(&label_end);

  asm_label(&label_then);
  asm_cp(&s_1, &s_reg_a);

  asm_label(&label_end);
end

def _gen_expr_neq(g_)
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [6]s_reg_b; str_set_reg_b(&s_reg_b);
  var [2]s_0;
  var [2]s_1;
  var label_end_size = 13; var [13]label_end; # end_neq_xxxx ... 12 chars + 1
  var label_then_size = 10; var [10]label_then; # then_xxxx ... 9 chars + 1
  var label_id;

  aset(&s_0, 0, 48); # 0
  aset(&s_0, 1,  0);

  aset(&s_1, 0, 49); # 1
  aset(&s_1, 1,  0);

  inc_label_id(g_);
  label_id = get_label_id(g_);

  aset(&label_end, 0, 101); # e
  aset(&label_end, 1, 110); # n
  aset(&label_end, 2, 100); # d
  aset(&label_end, 3,  95); # _
  aset(&label_end, 4, 110); # n
  aset(&label_end, 5, 101); # e
  aset(&label_end, 6, 113); # q
  aset(&label_end, 7,   0);
  append_label_id(&label_end, label_id, label_end_size);

  aset(&label_then, 0, 116); # t
  aset(&label_then, 1, 104); # h
  aset(&label_then, 2, 101); # e
  aset(&label_then, 3, 110); # n
  aset(&label_then, 4,   0);
  append_label_id(&label_then, label_id, label_then_size);

  asm_pop(&s_reg_b);
  asm_pop(&s_reg_a);

  asm_compare();

  asm_jump_eq(&label_then);

  asm_cp(&s_1, &s_reg_a);

  asm_jump(&label_end);

  asm_label(&label_then);
  asm_cp(&s_0, &s_reg_a);

  asm_label(&label_end);
end

def _gen_expr_binary(g_, fn_arg_names_, lvar_names_, expr_)
  var expr_els_ = Node_get_list(expr_);
  var op_str_ = NodeList_get_as_str(expr_els_, 0);
  var arg_l_ = NodeList_get(expr_els_, 1);
  var arg_r_ = NodeList_get(expr_els_, 2);
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [3]s_eq;
  var [4]s_neq;

  aset(&s_eq, 0, 101); # e
  aset(&s_eq, 1, 113); # q
  aset(&s_eq, 2,   0);

  aset(&s_neq, 0, 110); # n
  aset(&s_neq, 1, 101); # e
  aset(&s_neq, 2, 113); # q
  aset(&s_neq, 3,   0);

  gen_expr(g_, fn_arg_names_, lvar_names_, arg_l_);
  asm_push(&s_reg_a);

  gen_expr(g_, fn_arg_names_, lvar_names_, arg_r_);
  asm_push(&s_reg_a);

  case
  when (char_at(op_str_, 0) == 43) # +
    _gen_expr_add();
  when (char_at(op_str_, 0) == 42) # *
    _gen_expr_mult();
  when (str_eq(op_str_, &s_eq)) # eq
    _gen_expr_eq(g_);
  when (str_eq(op_str_, &s_neq)) # neq
    _gen_expr_neq(g_);
  else
    panic(284); # _gen_expr_binary: not yet impl
  end
end

def gen_expr(g_, fn_arg_names_, lvar_names_, expr_)
  var [20]cp_src;
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [8]s_funcall; str_set_funcall(&s_funcall);
  var expr;
  var str_;
  var vram_param_size = 20; var [20]vram_param;
  var size;
  var [8]vram_addr;
  var list_;

  case
  when (Node_kind_eq(expr_, NODE_KIND__INT()))
    expr = Node_get_int(expr_);
    unparse_int(&cp_src, expr);
    asm_cp(&cp_src, &s_reg_a);

  when (Node_kind_eq(expr_, NODE_KIND__STR()))
    str_ = Node_get_str(expr_);

    case
    when (Names_includes(fn_arg_names_, str_))
      to_fn_arg_addr(&cp_src, fn_arg_names_, str_);
      asm_cp(&cp_src, &s_reg_a);

    when (Names_includes(lvar_names_, str_))
      to_lvar_addr(&cp_src, lvar_names_, str_);
      asm_cp(&cp_src, &s_reg_a);

    when (0 < match_vram(str_))
      size = match_vram(str_);
      substr_with_check(&vram_param, str_, 5, 5 + size, vram_param_size);

      if (Names_includes(lvar_names_, &vram_param))
        to_lvar_addr(&vram_addr, lvar_names_, &vram_param);
        asm_get_vram(&vram_addr, &s_reg_a);
      else
        panic(703);
      end

    else
      Json_print(Names_to_plain(g_, fn_arg_names_));
      Json_print(Names_to_plain(g_, lvar_names_));
      Json_print_node(expr_);
      panic(336); # gen_expr: not yet implemented
    end

  when (Node_kind_eq(expr_, NODE_KIND__LIST()))
    list_ = Node_get_list(expr_);

    if (str_eq(
          NodeList_get_as_str(list_, 0),
          &s_funcall
        ))
      gen_call(g_, fn_arg_names_, lvar_names_, list_);
    else
      _gen_expr_binary(g_, fn_arg_names_, lvar_names_, expr_);
    end

  else
    Json_print_node(expr_);
    panic(344); # gen_expr: not yet implemented
  end
end

def gen_call(g_, fn_arg_names_, lvar_names_, stmt_)
  var vm_comment_size = 32; var [32]vm_comment;
  var fn_name_;
  var args_;
  var i;
  var node_;
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);

  fn_name_ = NodeList_get_as_str(stmt_, 1);
  args_ = NodeList_rest(g_, stmt_, 2);

  str_set_call(&vm_comment);
  aset(&vm_comment, 4, C_SPC());
  aset(&vm_comment, 5, C_SPC());
  aset(&vm_comment, 6, 0);
  str_append_with_check(
    &vm_comment, fn_name_,
    vm_comment_size
  );

  i = __sub(NodeList_size(args_), 1);
  while (__le(0, i))
    node_ = NodeList_get(args_, i);
    gen_expr(g_, fn_arg_names_, lvar_names_, node_);
    asm_push(&s_reg_a);
    i = __sub(i, 1);
  end

  asm_vm_comment(&vm_comment);
  asm_call(fn_name_);
  asm_add_sp(NodeList_size(args_));
end

def gen_set(g_, fn_arg_names_, lvar_names_, stmt_)
  var [8]dest;
  var [8]dest_str_;
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var expr_node_;
  var size;
  var [8]vram_param;
  var [8]vram_addr;

  dest_str_ = NodeList_get_as_str(stmt_, 1);
  expr_node_ = NodeList_get(stmt_, 2);

  gen_expr(g_, fn_arg_names_, lvar_names_, expr_node_);

  case
  when (Names_includes(lvar_names_, dest_str_))

    to_lvar_addr(
      &dest,
      lvar_names_,
      dest_str_
    );

    asm_cp(&s_reg_a, &dest);

  when (0 < match_vram(dest_str_))
    size = match_vram(dest_str_);
    substr(&vram_param, dest_str_, 5, 5 + size);

    if (Names_includes(lvar_names_, &vram_param))
      to_lvar_addr(&vram_addr, lvar_names_, &vram_param);
      asm_set_vram(&vram_addr, &s_reg_a);
    else
      panic(703);
    end

  else
    Json_print(stmt_);
    p_s(&dest);
    panic(823);
  end
end

def gen_return(g_, fn_arg_names_, lvar_names_, stmt_)
  var expr_ = NodeList_get(stmt_, 1);
  gen_expr(g_, fn_arg_names_, lvar_names_, expr_);
end

def gen_vm_comment(stmt_)
  asm_vm_comment(NodeList_get_as_str(stmt_, 1));
end

def gen_stmt(g_, fn_arg_names_, lvar_names_, stmt_)
  var head_str_ = NodeList_get_as_str(stmt_, 0);

  case
  when (str_eq_set(head_str_))
    gen_set(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq__cmt(head_str_))
    gen_vm_comment(stmt_);
  when (str_eq_call(head_str_))
    gen_call(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq_return(head_str_))
    gen_return(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq_while(head_str_))
    gen_while(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq_case(head_str_))
    gen_case(g_, fn_arg_names_, lvar_names_, stmt_);
  else
    panic(365); # gen_stmt
  end
end

def gen_stmts(g_, fn_arg_names_, lvar_names_, stmts_)
  var i = 0;
  var stmt_;

  while (i < NodeList_size(stmts_))
    stmt_ = NodeList_get_as_list(stmts_, i);
    gen_stmt(g_, fn_arg_names_, lvar_names_, stmt_);
    i = i + 1;
  end
end

def gen_func(g_, func_)
  var fn_name_;
  var stmts_;
  var stmt_;
  var i;
  var lvar_names_;
  var lvar_name_;
  var fn_arg_names_;

  assert(4, NodeList_size(func_), 243);

  fn_name_ = Node_get_str(NodeList_get(func_, 1));

  fn_arg_names_ =
    Names_from_node_list(
      g_,
      NodeList_get_as_list(func_, 2)
    );

  stmts_ = Node_get_list(NodeList_get(func_, 3));

  asm_label(fn_name_);

  asm_fn_prologue();

  lvar_names_ = Names_new(g_);

  i = 0;
  while (i < NodeList_size(stmts_))
    stmt_ = NodeList_get_as_list(stmts_, i);

    if (str_eq_var(NodeList_get_as_str(stmt_, 0)))
      lvar_name_ = NodeList_get_as_str(stmt_, 1);
      Names_add(lvar_names_, lvar_name_);
      gen_var(g_, fn_arg_names_, lvar_names_, stmt_);
    else
      gen_stmt(g_, fn_arg_names_, lvar_names_, stmt_);
    end

    i = i + 1;
  end

  asm_fn_epilogue();

  asm_ret();
end

def gen_top_stmt(g_, top_stmt_)
  var head_ = NodeList_get(top_stmt_, 0);

  case
  when (str_eq_func(Node_get_str(head_)))
    gen_func(g_, top_stmt_);
  else
    panic(194);
  end
end

def gen_top_stmts(g_, top_stmts_)
  var i;
  var top_stmt_;

  i = 1;
  while (i < NodeList_size(top_stmts_))
    top_stmt_ = NodeList_get_as_list(top_stmts_, i);
    gen_top_stmt(g_, top_stmt_);
    i = i + 1;
  end
end

def gen_builtin_set_vram()
  var [3]s_bp; str_set_bp(&s_bp);
  var [9]s_set_vram;

  aset(&s_set_vram, 0, 115); # s
  aset(&s_set_vram, 1, 101); # e
  aset(&s_set_vram, 2, 116); # t
  aset(&s_set_vram, 3,  95); # _
  aset(&s_set_vram, 4, 118); # v
  aset(&s_set_vram, 5, 114); # r
  aset(&s_set_vram, 6,  97); # a
  aset(&s_set_vram, 7, 109); # m
  aset(&s_set_vram, 8,   0);

  asm_label(&s_set_vram);

  asm_fn_prologue();

  # set_vram [bp:2] [bp:3]" # vram_addr value
  asm_indent();
  print_s(&s_set_vram);

  putchar(C_SPC());
  putchar( 91); # [
  print_s(&s_bp);
  putchar( 58); # :
  print_i(2);
  putchar( 93); # ]

  putchar(C_SPC());
  putchar( 91); # [
  print_s(&s_bp);
  putchar( 58); # :
  print_i(3);
  putchar( 93); # ]

  putchar(C_LF());

  asm_fn_epilogue();

  asm_ret();
end

def gen_builtin_get_vram()
  var [3]s_bp; str_set_bp(&s_bp);
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [9]s_get_vram;

  aset(&s_get_vram, 0, 103); # g
  aset(&s_get_vram, 1, 101); # e
  aset(&s_get_vram, 2, 116); # t
  aset(&s_get_vram, 3,  95); # _
  aset(&s_get_vram, 4, 118); # v
  aset(&s_get_vram, 5, 114); # r
  aset(&s_get_vram, 6,  97); # a
  aset(&s_get_vram, 7, 109); # m
  aset(&s_get_vram, 8,   0);

  asm_label(&s_get_vram);

  asm_fn_prologue();

  # get_vram [bp:2] reg_a"
  asm_indent();
  print_s(&s_get_vram);

  putchar(C_SPC());
  putchar( 91); # [
  print_s(&s_bp);
  putchar( 58); # :
  print_i(2);
  putchar( 93); # ]

  putchar(C_SPC());
  print_s(&s_reg_a);

  putchar(C_LF());

  asm_fn_epilogue();

  asm_ret();
end

def codegen(g_, ast_)
  var [5]s_temp;

  aset(&s_temp, 0, 109); # m
  aset(&s_temp, 1,  97); # a
  aset(&s_temp, 2, 105); # i
  aset(&s_temp, 3, 110); # n
  aset(&s_temp, 4,   0);
  asm_call(&s_temp);

  asm_exit();

  gen_builtin_set_vram();
  gen_builtin_get_vram();

  gen_top_stmts(g_, ast_);
end

def GO_LABEL_ID() return GO_ALLOC_CURSOR() + GS_ALLOC_CURSOR(); end
def GS_LABEL_ID() return 1; end

def get_label_id(g_)
  return *(g_ + GO_LABEL_ID());
end

def inc_label_id(g_)
  *(g_ + GO_LABEL_ID()) = get_label_id(g_) + 1;
end

def load_ast(g_)
  var input_size_max = 14000; var [14000]input;

  read_stdin_all(&input, input_size_max);
  return Json_parse(g_, &input);
end

def main()
  var [2]g;
  var ast_;

  # init globals
  init_alloc_cursor(&g);

  ast_ = load_ast(&g);

  codegen(&g, ast_);
end
