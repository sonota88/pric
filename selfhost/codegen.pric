# -*- mode: ruby -*-

#include lib/std.pric
#include lib/words.pric
#include lib/types.pric
#include lib/json.pric

# --------------------------------

def asm_indent()
  putchar(C_SPC());
  putchar(C_SPC());
end

def asm_exit()
  var [5]temp_str;

  aset(&temp_str, 0, 101); # e
  aset(&temp_str, 1, 120); # x
  aset(&temp_str, 2, 105); # i
  aset(&temp_str, 3, 116); # t
  aset(&temp_str, 4,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_LF());
end

def asm_label(label_)
  var [6]temp_str;

  aset(&temp_str, 0, 108); # l
  aset(&temp_str, 1,  97); # a
  aset(&temp_str, 2,  98); # b
  aset(&temp_str, 3, 101); # e
  aset(&temp_str, 4, 108); # l
  aset(&temp_str, 5,   0);

  print_s(&temp_str);
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_call(label_)
  var [5]temp_str;

  aset(&temp_str, 0,  99); # c
  aset(&temp_str, 1,  97); # a
  aset(&temp_str, 2, 108); # l
  aset(&temp_str, 3, 108); # l
  aset(&temp_str, 4,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_ret()
  var [4]temp_str;

  aset(&temp_str, 0, 114); # r
  aset(&temp_str, 1, 101); # e
  aset(&temp_str, 2, 116); # t
  aset(&temp_str, 3,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_LF());
end

def asm_cp(src_, dest_)
  var [3]temp_str;

  aset(&temp_str, 0,  99); # c
  aset(&temp_str, 1, 112); # p
  aset(&temp_str, 2,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(src_);
  putchar(C_SPC());
  print_s(dest_);
  putchar(C_LF());
end

def asm_push(arg_)
  var [5]temp_str;

  aset(&temp_str, 0, 112); # p
  aset(&temp_str, 1, 117); # u
  aset(&temp_str, 2, 115); # s
  aset(&temp_str, 3, 104); # h
  aset(&temp_str, 4,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(arg_);
  putchar(C_LF());
end

def asm_pop(dest_)
  var [4]temp_str;

  aset(&temp_str, 0, 112); # p
  aset(&temp_str, 1, 111); # o
  aset(&temp_str, 2, 112); # p
  aset(&temp_str, 3,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(dest_);
  putchar(C_LF());
end

def asm_sub_sp(n)
  var [7]temp_str;

  aset(&temp_str, 0, 115); # s
  aset(&temp_str, 1, 117); # u
  aset(&temp_str, 2,  98); # b
  aset(&temp_str, 3,  95); # _
  aset(&temp_str, 4, 115); # s
  aset(&temp_str, 5, 112); # p
  aset(&temp_str, 6,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_i(n);
  putchar(C_LF());
end

def asm_add_sp(n)
  var [7]temp_str;

  aset(&temp_str, 0,  97); # a
  aset(&temp_str, 1, 100); # d
  aset(&temp_str, 2, 100); # d
  aset(&temp_str, 3,  95); # _
  aset(&temp_str, 4, 115); # s
  aset(&temp_str, 5, 112); # p
  aset(&temp_str, 6,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_i(n);
  putchar(C_LF());
end

def asm_compare()
  asm_indent();
  putchar( 99); # c
  putchar(111); # o
  putchar(109); # m
  putchar(112); # p
  putchar( 97); # a
  putchar(114); # r
  putchar(101); # e
  putchar(C_LF());
end

def asm_jump(label_)
  asm_indent();
  putchar(106); # j
  putchar(117); # u
  putchar(109); # m
  putchar(112); # p
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_jump_eq(label_)
  asm_indent();
  putchar(106); # j
  putchar(117); # u
  putchar(109); # m
  putchar(112); # p
  putchar( 95); # _
  putchar(101); # e
  putchar(113); # q
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_vm_comment(vm_comment_)
  var [5] str__cmt; str_set__cmt(&str__cmt);
  var vm_comment_size = 11; var [11]vm_comment;
  var i;
  var c;

  str_cp_with_check(
    &vm_comment, vm_comment_,
    vm_comment_size
  );

  i = 0;
  while (i < str_size(&vm_comment))
    c = char_at(&vm_comment, i);
    if (c == C_SPC())
      c = 126; # ~
      aset(&vm_comment, i, c);
    end
    i = i + 1;
  end

  asm_indent();
  print_s(&str__cmt);
  putchar(C_SPC());
  print_s(&vm_comment);
  putchar(C_LF());
end

def asm_fn_prologue()
  var [3]s_bp; str_set_bp(&s_bp);
  var [3]s_sp; str_set_sp(&s_sp);

  asm_push(&s_bp);
  asm_cp(&s_sp, &s_bp);
end

def asm_fn_epilogue()
  var [3]s_bp; str_set_bp(&s_bp);
  var [3]s_sp; str_set_sp(&s_sp);

  asm_cp(&s_bp, &s_sp);
  asm_pop(&s_bp);
end

# --------------------------------

def to_fn_arg_addr(dest_, names_, name_)
  var idx = Names_index(names_, name_);

  aset(dest_, 0,  91); # [
  aset(dest_, 1,  98); # b
  aset(dest_, 2, 112); # p
  aset(dest_, 3,  58); # :

  if ((idx + 1) < 10)
    aset(dest_, 4, i_to_c(idx + 2));
  else
    panic(230); # to_fn_arg_addr: not yet supported
  end

  aset(dest_, 5,  93); # ]
  aset(dest_, 6,   0);
end

def to_lvar_addr(dest_, names_, name_)
  var idx = Names_index(names_, name_);
  assert(0, idx, 175);

  aset(dest_, 0,  91); # [
  aset(dest_, 1,  98); # b
  aset(dest_, 2, 112); # p
  aset(dest_, 3,  58); # :
  aset(dest_, 4,  45); # -

  if ((idx + 1) < 10)
    aset(dest_, 5, i_to_c(idx + 1));
  else
    panic(181); # to_lvar_addr: not yet supported
  end

  aset(dest_, 6,  93); # ]
  aset(dest_, 7,   0);
end

def render_label_id(label_, id, dest_size)
  var [2]underscore;
  var [8]id_str;

  aset(&underscore, 0, 95); # _
  aset(&underscore, 1,  0);
  str_append_with_check(label_, &underscore, dest_size);

  unparse_int(&id_str, id);
  str_append_with_check(label_, &id_str, dest_size);
end

# --------------------------------

def gen_var(g_, fn_arg_names_, lvar_names_, stmt_)
  var set_stmt_;
  var [4]str_set; str_set_set(&str_set);

  asm_sub_sp(1);

  if (NodeList_size(stmt_) == 3)
    set_stmt_ = NodeList_new(g_);
    NodeList_add_str(g_, set_stmt_, &str_set);
    NodeList_add(set_stmt_, NodeList_get(stmt_, 1));
    NodeList_add(set_stmt_, NodeList_get(stmt_, 2));

    gen_set(g_, fn_arg_names_, lvar_names_, set_stmt_);
  end
end

# TODO gen_case

def gen_while(g_, fn_arg_names_, lvar_names_, stmt_)
  var [6]s_reg_a; str_set_reg_a(&s_reg_a);
  var [6]s_reg_b; str_set_reg_b(&s_reg_b);

  var [2]s_0;
  var [2]s_1;

  var label_begin_size = 11; var [11]label_begin; # while_xxxx
  var label_end_size = 15; var [15]label_end; # end_while_xxxx
  var label_true_size = 10; var [10]label_true; # true_xxxx

  var label_id;
  var cond_expr_node_ = NodeList_get(stmt_, 1);

  aset(&s_0, 0, 48); # 0
  aset(&s_0, 1,  0);

  aset(&s_1, 0, 49); # 1
  aset(&s_1, 1,  0);

  inc_label_id(g_);
  label_id = get_label_id(g_);

  aset(&label_begin, 0, 119); # w
  aset(&label_begin, 1, 104); # h
  aset(&label_begin, 2, 105); # i
  aset(&label_begin, 3, 108); # l
  aset(&label_begin, 4, 101); # e
  aset(&label_begin, 5,   0);
  render_label_id(&label_begin, label_id, label_begin_size);

  aset(&label_end,  0, 101); # e
  aset(&label_end,  1, 110); # n
  aset(&label_end,  2, 100); # d
  aset(&label_end,  3,  95); # _
  aset(&label_end,  4, 119); # w
  aset(&label_end,  5, 104); # h
  aset(&label_end,  6, 105); # i
  aset(&label_end,  7, 108); # l
  aset(&label_end,  8, 101); # e
  aset(&label_end, 9,   0);
  render_label_id(&label_end, label_id, label_end_size);

  aset(&label_true, 0, 116); # t
  aset(&label_true, 1, 114); # r
  aset(&label_true, 2, 117); # u
  aset(&label_true, 3, 101); # e
  aset(&label_true, 4,   0);
  render_label_id(&label_true, label_id, label_true_size);

  asm_label(&label_begin);

  gen_expr(g_, fn_arg_names_, lvar_names_, cond_expr_node_);

  asm_cp(&s_1, &s_reg_b);

  asm_compare();

  asm_jump_eq(&label_true);

  asm_jump(&label_end);


  asm_label(&label_true);

  asm_cp(&s_1, &s_reg_a);

  asm_indent();
  putchar( 99); # c
  putchar(112); # p
  putchar(C_SPC()); #  
  putchar(114); # r
  putchar(101); # e
  putchar(103); # g
  putchar( 95); # _
  putchar( 97); # a
  putchar(C_SPC()); #  
  putchar( 91); # [
  putchar( 98); # b
  putchar(112); # p
  putchar( 58); # :
  putchar( 45); # -
  putchar( 49); # 1
  putchar( 93); # ]
  putchar(C_LF());

  asm_jump(&label_begin);


  asm_label(&label_end);
end

def _gen_expr_add()
  var [6]str_reg_a; str_set_reg_a(&str_reg_a);
  var [6]str_reg_b; str_set_reg_b(&str_reg_b);

  asm_pop(&str_reg_b);
  asm_pop(&str_reg_a);

  asm_indent();
  putchar( 97); # a
  putchar(100); # d
  putchar(100); # d
  putchar( 95); # _
  putchar( 97); # a
  putchar( 98); # b
  putchar(C_LF());
end

# TODO _gen_expr_mult

def _gen_expr_eq(g_)
  var [6]str_reg_a; str_set_reg_a(&str_reg_a);
  var [6]str_reg_b; str_set_reg_b(&str_reg_b);
  var [2]str_0;
  var [2]str_1;
  var label_end_size = 9; var [9]label_end;
  var label_then_size = 7; var [7]label_then;
  var label_id;

  aset(&str_0, 0, 48); # 0
  aset(&str_0, 1,  0);

  aset(&str_1, 0, 49); # 1
  aset(&str_1, 1,  0);

  inc_label_id(g_);
  label_id = get_label_id(g_);

  aset(&label_end, 0, 101); # e
  aset(&label_end, 1, 110); # n
  aset(&label_end, 2, 100); # d
  aset(&label_end, 3,  95); # _
  aset(&label_end, 4, 101); # e
  aset(&label_end, 5, 113); # q
  aset(&label_end, 6,   0);
  render_label_id(&label_end, label_id, label_end_size);

  aset(&label_then, 0, 116); # t
  aset(&label_then, 1, 104); # h
  aset(&label_then, 2, 101); # e
  aset(&label_then, 3, 110); # n
  aset(&label_then, 4,   0);
  render_label_id(&label_then, label_id, label_then_size);

  asm_pop(&str_reg_b);
  asm_pop(&str_reg_a);

  asm_compare();

  asm_jump_eq(&label_then);

  asm_cp(&str_0, &str_reg_a);

  asm_jump(&label_end);

  asm_label(&label_then);
  asm_cp(&str_1, &str_reg_a);

  asm_label(&label_end);
end

# TODO _gen_expr_neq

def _gen_expr_binary(g_, fn_arg_names_, lvar_names_, expr_)
  var expr_els_ = Node_get_list(expr_);
  var op_str_ = NodeList_get_as_str(expr_els_, 0);
  var arg_l_ = NodeList_get(expr_els_, 1);
  var arg_r_ = NodeList_get(expr_els_, 2);
  var [6]str_reg_a; str_set_reg_a(&str_reg_a);
  var [3]str_eq_op;

  aset(&str_eq_op, 0, 101); # e
  aset(&str_eq_op, 1, 113); # q
  aset(&str_eq_op, 2,   0);

  gen_expr(g_, fn_arg_names_, lvar_names_, arg_l_);
  asm_push(&str_reg_a);

  gen_expr(g_, fn_arg_names_, lvar_names_, arg_r_);
  asm_push(&str_reg_a);

  case
  when (char_at(op_str_, 0) == 43) # +
    _gen_expr_add();
  when (str_eq(op_str_, &str_eq_op)) # eq
    _gen_expr_eq(g_);
  else
    panic(284); # _gen_expr_binary: not yet impl
  end
end

def gen_expr(g_, fn_arg_names_, lvar_names_, expr_)
  var [10]cp_src;
  var [6]str_reg_a; str_set_reg_a(&str_reg_a);
  var expr;
  var str_;

  case
  when (Node_kind_eq(expr_, NODE_KIND__INT()))
    expr = Node_get_int(expr_);
    unparse_int(&cp_src, expr);
    asm_cp(&cp_src, &str_reg_a);

  when (Node_kind_eq(expr_, NODE_KIND__STR()))
    str_ = Node_get_str(expr_);

    case
    when (Names_includes(fn_arg_names_, str_))
      to_fn_arg_addr(&cp_src, fn_arg_names_, str_);
      asm_cp(&cp_src, &str_reg_a);

    when (Names_includes(lvar_names_, str_))
      to_lvar_addr(&cp_src, lvar_names_, str_);
      asm_cp(&cp_src, &str_reg_a);

    else
      Json_print_node(expr_);
      panic(336); # gen_expr: not yet implemented
    end

  when (Node_kind_eq(expr_, NODE_KIND__LIST()))
    _gen_expr_binary(g_, fn_arg_names_, lvar_names_, expr_);

  else
    Json_print_node(expr_);
    panic(344); # gen_expr: not yet implemented
  end
end

def gen_call(g_, fn_arg_names_, lvar_names_, stmt_)
  var vm_comment_size = 10; var [10]vm_comment;
  var fn_name_;
  var args_;
  var i;
  var node_;
  var [6]str_reg_a; str_set_reg_a(&str_reg_a);

  fn_name_ = NodeList_get_as_str(stmt_, 1);
  args_ = NodeList_rest(g_, stmt_, 2);

  str_set_call(&vm_comment);
  aset(&vm_comment, 4, C_SPC());
  aset(&vm_comment, 5, C_SPC());
  aset(&vm_comment, 6, 0);
  str_append_with_check(
    &vm_comment, fn_name_,
    vm_comment_size
  );

  i = __sub(NodeList_size(args_), 1);
  while (__le(0, i))
    node_ = NodeList_get(args_, i);
    gen_expr(g_, fn_arg_names_, lvar_names_, node_);
    asm_push(&str_reg_a);
    i = __sub(i, 1);
  end

  asm_vm_comment(&vm_comment);
  asm_call(fn_name_);
  asm_add_sp(NodeList_size(args_));
end

def gen_call_set(g_, fn_arg_names_, lvar_names_, stmt_)
  var [6]str_reg_a; str_set_reg_a(&str_reg_a);
  var [5]str_call; str_set_call(&str_call);

  var lvar_name_ = NodeList_get_as_str(stmt_, 1);
  var funcall_   = NodeList_get_as_list(stmt_, 2);

  var [10]lvar_addr;
  var call_stmt_;

  call_stmt_ = NodeList_new(g_);
  NodeList_add_str(g_, call_stmt_, &str_call);
  NodeList_add_all(call_stmt_, funcall_);

  gen_call(g_, fn_arg_names_, lvar_names_, call_stmt_);

  to_lvar_addr(&lvar_addr, lvar_names_, lvar_name_);

  asm_cp(&str_reg_a, &lvar_addr);
end

def gen_set(g_, fn_arg_names_, lvar_names_, stmt_)
  var [8]dest;
  var [8]lvar_name_;
  var [6]str_reg_a; str_set_reg_a(&str_reg_a);
  var expr_node_;

  lvar_name_ = NodeList_get_as_str(stmt_, 1);
  expr_node_ = NodeList_get(stmt_, 2);

  gen_expr(g_, fn_arg_names_, lvar_names_, expr_node_);

  to_lvar_addr(
    &dest,
    lvar_names_,
    lvar_name_
  );

  asm_cp(&str_reg_a, &dest);
end

def gen_return(g_, fn_arg_names_, lvar_names_, stmt_)
  var expr_ = NodeList_get(stmt_, 1);
  gen_expr(g_, fn_arg_names_, lvar_names_, expr_);
end

def gen_vm_comment(stmt_)
  asm_vm_comment(NodeList_get_as_str(stmt_, 1));
end

def gen_stmt(g_, fn_arg_names_, lvar_names_, stmt_)
  var head_str_ = NodeList_get_as_str(stmt_, 0);

  case
  when (str_eq_set(head_str_))
    gen_set(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq__cmt(head_str_))
    gen_vm_comment(stmt_);
  when (str_eq_call(head_str_))
    gen_call(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq_call_set(head_str_))
    gen_call_set(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq_return(head_str_))
    gen_return(g_, fn_arg_names_, lvar_names_, stmt_);
  when (str_eq_while(head_str_))
    gen_while(g_, fn_arg_names_, lvar_names_, stmt_);
  else
    panic(365); # gen_stmt
  end
end

# TODO gen_stmts

def gen_func(g_, func_)
  var fn_name_;
  var stmts_;
  var stmt_;
  var i;
  var lvar_names_;
  var lvar_name_;
  var fn_arg_names_;

  assert(4, NodeList_size(func_), 243);

  fn_name_ = Node_get_str(NodeList_get(func_, 1));

  fn_arg_names_ =
    Names_from_node_list(
      g_,
      NodeList_get_as_list(func_, 2)
    );

  stmts_ = Node_get_list(NodeList_get(func_, 3));

  asm_label(fn_name_);

  asm_fn_prologue();

  lvar_names_ = Names_new(g_);

  i = 0;
  while (i < NodeList_size(stmts_))
    stmt_ = NodeList_get_as_list(stmts_, i);

    if (str_eq_var(NodeList_get_as_str(stmt_, 0)))
      lvar_name_ = NodeList_get_as_str(stmt_, 1);
      Names_add(lvar_names_, lvar_name_);
      gen_var(g_, fn_arg_names_, lvar_names_, stmt_);
    else
      gen_stmt(g_, fn_arg_names_, lvar_names_, stmt_);
    end

    i = i + 1;
  end

  asm_fn_epilogue();

  asm_ret();
end

def gen_top_stmt(g_, top_stmt_)
  var head_ = NodeList_get(top_stmt_, 0);

  case
  when (str_eq_func(Node_get_str(head_)))
    gen_func(g_, top_stmt_);
  else
    panic(194);
  end
end

def gen_top_stmts(g_, top_stmts_)
  var i;
  var top_stmt_;

  i = 1;
  while (i < NodeList_size(top_stmts_))
    top_stmt_ = NodeList_get_as_list(top_stmts_, i);
    gen_top_stmt(g_, top_stmt_);
    i = i + 1;
  end
end

def codegen(g_, ast_)
  var [5]temp_str;

  aset(&temp_str, 0, 109); # m
  aset(&temp_str, 1,  97); # a
  aset(&temp_str, 2, 105); # i
  aset(&temp_str, 3, 110); # n
  aset(&temp_str, 4,   0);
  asm_call(&temp_str);

  asm_exit();

  gen_top_stmts(g_, ast_);
end

def GO_LABEL_ID() return GO_ALLOC_CURSOR() + GS_ALLOC_CURSOR(); end
def GS_LABEL_ID() return 1; end

def get_label_id(g_)
  return *(g_ + GO_LABEL_ID());
end

def inc_label_id(g_)
  *(g_ + GO_LABEL_ID()) = get_label_id(g_) + 1;
end

def INPUT_MAX() return 600; end

def main()
  var [2]g;
  var [600]input; # INPUT_MAX
  var ast_;

  # init globals
  init_alloc_cursor(&g);

  read_stdin_all(&input, INPUT_MAX());

  ast_ = Json_parse(&g, &input);

  codegen(&g, ast_);
end
