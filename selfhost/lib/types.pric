# -*- mode: ruby -*-

def NODE_KIND__LIST() return 0; end
def NODE_KIND__INT () return 1; end
def NODE_KIND__STR () return 2; end

# --------------------------------

def NODE__TYPE_SIZE() return 43; end

def NODE__KIND() return 0; end
def NODE__LIST() return 1; end
def NODE__INT () return 2; end
def NODE__STR () return 3; end

def NODE__STR_SIZE() return 40; end

def Node_new(g_)
  var self_ = allocate(g_, NODE__TYPE_SIZE());
  return self_;
end

def Node_new_int(g_, n)
  var self_ = Node_new(g_);

  *(self_ + NODE__KIND()) = NODE_KIND__INT();
  *(self_ + NODE__INT()) = n;

  return self_;
end

def Node_new_str(g_, str_)
  var self_ = Node_new(g_);

  if (__le(NODE__STR_SIZE(), str_size(str_)))
    p_s(str_);
    panic(37);
  end

  *(self_ + NODE__KIND()) = NODE_KIND__STR();
  str_cp(self_ + NODE__STR(), str_);

  return self_;
end

def Node_new_list(g_, list_)
  var self_ = Node_new(g_);

  *(self_ + NODE__KIND()) = NODE_KIND__LIST();
  *(self_ + NODE__LIST()) = list_;

  return self_;
end

def Node_get_kind(self_)
  var kind = *(self_ + NODE__KIND());
  return kind;
end

def Node_get_int(self_)
  assert(NODE_KIND__INT(), Node_get_kind(self_), 62);

  var n = *(self_ + NODE__INT());
  return n;
end

def Node_get_str(self_)
  assert(NODE_KIND__STR(), Node_get_kind(self_), 69);

  var first_char_addr_ = self_ + NODE__STR();
  return first_char_addr_;
end

def Node_get_list(self_)
  assert(NODE_KIND__LIST(), Node_get_kind(self_), 77);

  var nl_ = *(self_ + NODE__LIST());
  return nl_;
end

def Node_kind_eq(self_, kind)
  return Node_get_kind(self_) == kind;
end

# --------------------------------

def NODE_LIST__TYPE_SIZE () return 51; end

def NODE_LIST__SIZE () return 0; end
def NODE_LIST__ITEMS() return 1; end # 1..50

def NodeList_new(g_)
  var self_ = allocate(g_, NODE_LIST__TYPE_SIZE());

  *(self_ + NODE_LIST__SIZE()) = 0;

  return self_;
end

def NodeList_size(self_)
  var size = *(self_ + NODE_LIST__SIZE());
  return size;
end

def NodeList_add(self_, node_)
  var size = *(self_ + NODE_LIST__SIZE());

  if ((NODE_LIST__TYPE_SIZE() + -1) == size)
    panic(114); # NodeList_add: capacity over
  end

  *(self_ + NODE_LIST__ITEMS() + size) = node_;
  *(self_ + NODE_LIST__SIZE()) = size + 1;
end

def NodeList_add_all(self_, list_)
  var i = 0;

  while (i < NodeList_size(list_))
    NodeList_add(self_, NodeList_get(list_, i));
    i = i + 1;
  end
end

def NodeList_add_int(g_, self_, n)
  var node_ = Node_new_int(g_, n);
  NodeList_add(self_, node_);
end

def NodeList_add_str(g_, self_, str_)
  var node_ = Node_new_str(g_, str_);
  NodeList_add(self_, node_);
end

def NodeList_add_list(g_, self_, list_)
  var node_ = Node_new_list(g_, list_);
  NodeList_add(self_, node_);
end

def NodeList_get(self_, i)
  var node_ = *(self_ + NODE_LIST__ITEMS() + i);
  return node_;
end

def NodeList_get_as_int(self_, i)
  var node_ = NodeList_get(self_, i);
  return Node_get_int(node_);
end

def NodeList_get_as_str(self_, i)
  var node_ = NodeList_get(self_, i);
  return Node_get_str(node_);
end

def NodeList_get_as_list(self_, i)
  var node_ = NodeList_get(self_, i);
  return Node_get_list(node_);
end

def NodeList_rest(g_, list_, n)
  var newlist_ = NodeList_new(g_);
  var i = 0;

  while ((n + i) < NodeList_size(list_))
    NodeList_add(newlist_, NodeList_get(list_, n + i));
    i = i + 1;
  end

  return newlist_;
end

# --------------------------------

def TOKEN_KIND__KW   () return 0; end
def TOKEN_KIND__SYM  () return 1; end
def TOKEN_KIND__INT  () return 2; end
def TOKEN_KIND__STR  () return 3; end
def TOKEN_KIND__IDENT() return 4; end

def TokenKind_from_str(str_)
  var c0 = char_at(str_, 0);
  var c1 = char_at(str_, 1);

  case
  when (c0 == 107) # k
    return TOKEN_KIND__KW();
  when (__and(c0 == 115, c1 == 121)) # sy
    return TOKEN_KIND__SYM();
  when (__and(c0 == 105, c1 == 110)) # in
    return TOKEN_KIND__INT();
  when (__and(c0 == 115, c1 == 116)) # st
    return TOKEN_KIND__STR();
  when (__and(c0 == 105, c1 == 100)) # id
    return TOKEN_KIND__IDENT();
  else
    panic(196);
  end
end

def TokenKind_to_str(str_, kind)
  case
  when (kind == TOKEN_KIND__KW())
    aset(str_, 0, 107); # k
    aset(str_, 1,   0);
  when (kind == TOKEN_KIND__SYM())
    aset(str_, 0, 115); # s
    aset(str_, 1, 121); # y
    aset(str_, 2,   0);
  when (kind == TOKEN_KIND__INT())
    aset(str_, 0, 105); # i
    aset(str_, 1, 110); # n
    aset(str_, 2,   0);
  when (kind == TOKEN_KIND__STR())
    aset(str_, 0, 115); # s
    aset(str_, 1, 116); # t
    aset(str_, 2,   0);
  when (kind == TOKEN_KIND__IDENT())
    aset(str_, 0, 105); # i
    aset(str_, 1, 100); # d
    aset(str_, 2,   0);
  else
    panic(222);
  end
end

# --------------------------------

def TOKEN__TYPE_SIZE () return 41; end

def TOKEN__KIND() return 0; end
def TOKEN__VAL () return 1; end

def TOKEN__VAL_SIZE() return 40; end

def Token_new(g_, kind_str_, str_)
  var self_ = allocate(g_, TOKEN__TYPE_SIZE());

  *(self_ + TOKEN__KIND()) = TokenKind_from_str(kind_str_);

  if (TOKEN__VAL_SIZE() < (str_size(str_) + 1))
    p_s(str_);
    panic(180); # Token_new: string is too long
  else
    str_cp(self_ + TOKEN__VAL(), str_);
  end

  return self_;
end

def Token_get_kind(self_)
  return *(self_ + TOKEN__KIND());
end

def Token_get_val(self_)
  return self_ + TOKEN__VAL();
end

def Token_kind_eq(self_, kind)
  return Token_get_kind(self_) == kind;
end

def Token_val_eq(self_, value_)
  return str_eq(Token_get_val(self_), value_);
end

def Token_to_plain(g_, self_)
  var list_ = NodeList_new(g_);
  var kind = Token_get_kind(self_);
  var kind_str_ = allocate(g_, 3);

  TokenKind_to_str(kind_str_, kind);

  NodeList_add_int(g_, list_, kind);
  NodeList_add_str(g_, list_, kind_str_);
  NodeList_add_str(g_, list_, Token_get_val(self_));

  return list_;
end

# --------------------------------

def NAMES__TYPE_SIZE() return 97; end

def NAMES__STR_SIZE_MAX () return 16; end
def NAMES__NUM_STRS_MAX () return 6; end

def NAMES__SIZE () return 0; end
def NAMES__STRS() return 1; end # 1..96(= 16 * 6)

def Names_new(g_)
  var self_ = allocate(g_, NAMES__TYPE_SIZE());

  *(self_ + NAMES__SIZE()) = 0;

  return self_;
end

def Names_size(self_)
  return *(self_ + NAMES__SIZE());
end

def Names_str_offset(self_, i)
  return (
    self_
    + NAMES__STRS()
    + (NAMES__STR_SIZE_MAX() * i)
  );
end

def Names_add(self_, name_)
  var size = Names_size(self_);

  if (__le(NAMES__NUM_STRS_MAX(), size))
    p_i(NAMES__NUM_STRS_MAX());
    p_i(size);
    panic(316);
  end

  str_cp_with_check(
    Names_str_offset(self_, size),
    name_,
    NAMES__STR_SIZE_MAX()
  );

  *(self_ + NAMES__SIZE()) = size + 1;
end

def Names_get(self_, i)
  return Names_str_offset(self_, i);
end

def Names_index(self_, target_name_)
  var i;
  var result = -1;
  var size = Names_size(self_);
  var name_;
  var do_break = FALSE();

  i = 0;
  while (__not(do_break))
    name_ = Names_get(self_, i);
    case
    when (__le(size, i))
      do_break = TRUE();
    when (str_eq(name_, target_name_))
      do_break = TRUE();
      result = i;
    end
    i = i + 1;
  end

  return result;
end

def Names_includes(self_, target_name_)
  var i = Names_index(self_, target_name_);

  return __le(0, i);
end

def Names_from_node_list(g_, list_)
  var names_ = Names_new(g_);
  var i;
  var size = NodeList_size(list_);

  i = 0;
  while (i < size)
    Names_add(
      names_,
      NodeList_get_as_str(list_, i)
    );
    i = i + 1;
  end

  return names_;
end

def Names_to_plain(g_, self_)
  var list_ = NodeList_new(g_);
  var i = 0;

  while (i < Names_size(self_))
    NodeList_add_str(g_, list_, Names_get(self_, i));
    i = i + 1;
  end

  return list_;
end
