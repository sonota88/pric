# -*- mode: ruby -*-

#include lib/std.pric
#include lib/words.pric
#include lib/types.pric
#include lib/json.pric

def INPUT_MAX() return 300; end

def get_line_size(input_, pos_from)
  var pos_to;
  var lf_pos = char_index(input_, C_LF(), pos_from);

  if (lf_pos != -1)
    pos_to = lf_pos + 1;
  else
    # LF not found
    pos_to = char_index(input_, 0, pos_from);
  end

  return __sub(pos_to, pos_from);
end

def set_token(g_, ti, t_)
  if (__le(NUM_TOKENS_MAX(), ti))
    p_int(NUM_TOKENS_MAX());
    p_int(ti);
    panic(27); # set_token: cap over
  end
  aset(g_ + GO_TOKENS(), ti, t_);
end

def read_tokens(g_, input_)
  var do_break = FALSE();
  var [20]line;
  var size;
  var pos = 0;
  var sep_i;
  var [6]kind_str;
  var [64]value_str;
  var t_;
  var ti;
  check_heap_stack_overlap(g_);

  while (__not(do_break))
    size = get_line_size(input_, pos);
    if (size == 0)
      do_break = TRUE();
    else
      substr(&line, input_, pos, pos + size);
      chomp(&line);

      sep_i = char_index(&line, 58, 0); # :
      substr(&kind_str, &line, 0, sep_i);
      substr(&value_str, &line, sep_i + 1, str_size(&line));

      t_ = Token_new(g_, &kind_str, &value_str);
      set_token(g_, ti, t_);
      ti = ti + 1;

      pos = pos + size;
    end
  end

  return ti;
end

def set_num_tokens(g_, num_tokens)
  *(g_ + GO_NUM_TOKENS()) = num_tokens;
end

def get_num_tokens(g_)
  return *(g_ + GO_NUM_TOKENS());
end

def is_end(g_)
  var num_tokens = get_num_tokens(g_);
  var ti = get_token_index(g_);

  return __le(num_tokens, ti);
end

# --------------------------------

def set_token_index(g_, ti)
  *(g_ + GO_TOKEN_INDEX()) = ti;
end

def get_token_index(g_)
  return *(g_ + GO_TOKEN_INDEX());
end

def inc_token_index(g_)
  set_token_index(
    g_,
    get_token_index(g_) + 1
  );
end

def peek(g_, i)
  var ti = get_token_index(g_);
  return *(g_ + GO_TOKENS() + ti + i);
end

def consume_kw(g_, str_)
  var t_ = peek(g_, 0);
  if (__and(
        Token_kind_eq(t_, TOKEN_KIND__KW()),
        Token_val_eq(t_, str_)
  ))
    inc_token_index(g_);
  else
    p_int(Token_get_kind(t_));
    print_s(Token_get_val(t_));
    print_s(str_);
    panic(98);
  end
end

def consume_sym(g_, str_)
  var t_ = peek(g_, 0);
  if (__and(
        Token_kind_eq(t_, TOKEN_KIND__SYM()),
        Token_val_eq(t_, str_)
  ))
    inc_token_index(g_);
  else
    p_int(Token_get_kind(t_));
    p_str(Token_get_val(t_));
    p_str(str_);
    panic(117); # consume_sym: unexpected token
  end
end

# --------------------------------

def consume_sym_paren_l(g_)
  var [2]str;

  aset(&str, 0, 40); # (
  aset(&str, 1,  0);

  consume_sym(g_, &str);
end

def consume_sym_paren_r(g_)
  var [2]str;

  aset(&str, 0, 41); # )
  aset(&str, 1,  0);

  consume_sym(g_, &str);
end

def consume_sym_cbracket_l(g_)
  var [2]str;

  aset(&str, 0, 123); # {
  aset(&str, 1,   0);

  consume_sym(g_, &str);
end

def consume_sym_cbracket_r(g_)
  var [2]str;

  aset(&str, 0, 125); # }
  aset(&str, 1,   0);

  consume_sym(g_, &str);
end

def consume_sym_semicolon(g_)
  var [2]str;

  aset(&str, 0, 59); # ;
  aset(&str, 1,  0);

  consume_sym(g_, &str);
end

def consume_sym_equal(g_)
  var [2]str;

  aset(&str, 0, 61); # =
  aset(&str, 1,  0);

  consume_sym(g_, &str);
end

# --------------------------------

def _parse_arg(g_)
  var n;
  var t_ = peek(g_, 0);
  inc_token_index(g_);

  case
  when (Token_kind_eq(t_, TOKEN_KIND__IDENT()))
    return Node_new_str(g_, Token_get_val(t_));
  when (Token_kind_eq(t_, TOKEN_KIND__INT()))
    n = parse_int(Token_get_val(t_));
    return Node_new_int(g_, n);
  else
    panic(202); # _parse_arg: unsupported
  end
end

def parse_args(g_)
  var args_;
  var t_;
  var arg_node_;
  var do_break = FALSE();

  args_ = NodeList_new(g_);

  t_ = peek(g_, 0);

  if (char_at(Token_get_val(t_), 0) == 41) # )
    return args_;
  else

    arg_node_ = _parse_arg(g_);
    NodeList_add(args_, arg_node_);

    while (__not(do_break))
      t_ = peek(g_, 0);

      if (char_at(Token_get_val(t_), 0) == 44) # ,
        inc_token_index(g_); # , TODO
        arg_node_ = _parse_arg(g_);
        NodeList_add(args_, arg_node_);
      else
        do_break = TRUE();
      end
    end

    return args_;

  end
end

def parse_func(g_)
  var func_main_;
  var [10]temp_str;
  var t_;
  var stmts_;
  var stmt_;
  var do_break = FALSE();
  var [4]str_var;
  var [5]str_func;
  var args_;
  check_heap_stack_overlap(g_);

  str_set_var(&str_var);
  str_set_func(&str_func);

  consume_kw(g_, &str_func);

  func_main_ = NodeList_new(g_);

  NodeList_add_str(g_, func_main_, &str_func);

  t_ = peek(g_, 0);
  inc_token_index(g_);
  NodeList_add_str(g_, func_main_, Token_get_val(t_));

  consume_sym_paren_l(g_); # (

  args_ = parse_args(g_);
  NodeList_add_list(g_, func_main_, args_);

  consume_sym_paren_r(g_); # )

  consume_sym_cbracket_l(g_); # {

  stmts_ = NodeList_new(g_);

  while(__not(do_break))
    t_ = peek(g_, 0);
    if (char_at(Token_get_val(t_), 0) == 125) # }
      do_break = TRUE();
    else

      if (str_eq(Token_get_val(t_), &str_var))
        stmt_ = parse_var(g_);
      else
        stmt_ = parse_stmt(g_);
      end
      NodeList_add_list(g_, stmts_, stmt_);

    end
  end

  consume_sym_cbracket_r(g_); # }

  NodeList_add_list(g_, func_main_, stmts_);

  return func_main_;
end

def _parse_var_declare(g_)
  var stmt_;
  var [4]str_var;
  var t_;
  var var_name_;
  check_heap_stack_overlap(g_);

  str_set_var(&str_var);

  stmt_ = NodeList_new(g_);

  consume_kw(g_, &str_var);
  NodeList_add_str(g_, stmt_, &str_var);

  t_ = peek(g_, 0);
  inc_token_index(g_);
  var_name_ = Token_get_val(t_);
  NodeList_add_str(g_, stmt_, var_name_);

  consume_sym_semicolon(g_); # ;

  return stmt_;
end

def _parse_var_init(g_)
  var stmt_;
  var [4]str_var;
  var t_;
  var var_name_;
  var expr_node_;
  check_heap_stack_overlap(g_);

  str_set_var(&str_var);

  stmt_ = NodeList_new(g_);

  consume_kw(g_, &str_var);
  NodeList_add_str(g_, stmt_, &str_var);

  t_ = peek(g_, 0);
  inc_token_index(g_);
  var_name_ = Token_get_val(t_);
  NodeList_add_str(g_, stmt_, var_name_);

  consume_sym_equal(g_); # =

  expr_node_ = parse_expr(g_);
  NodeList_add(stmt_, expr_node_);

  consume_sym_semicolon(g_); # ;

  return stmt_;
end

def parse_var(g_)
  var [2]str_semicolon;
  var [2]str_equal;
  var t_;

  aset(&str_semicolon, 0, 59); #;
  aset(&str_semicolon, 1,  0);

  aset(&str_equal, 0, 61); # =
  aset(&str_equal, 1,  0);

  t_ = peek(g_, 2);
  case
  when (Token_val_eq(t_, &str_semicolon))
    _parse_var_declare(g_);
  when (Token_val_eq(t_, &str_equal))
    _parse_var_init(g_);
  else
    print_s(Token_get_val(t_));
    panic(240); # must not happen
  end

end

def _parse_expr_right(g_, expr_node_l_)
  var t_ = peek(g_, 0);
  var expr_node_r_;
  var expr_els_;
  var [2]str_plus;

  aset(&str_plus, 0, 43); # +
  aset(&str_plus, 1,  0);

  if (char_at(Token_get_val(t_), 0) == 59) #;
    return expr_node_l_;
  else

    if (char_at(Token_get_val(t_), 0) == 43) # +
      inc_token_index(g_); # TODO
      expr_node_r_ = parse_expr(g_);

      expr_els_ = NodeList_new(g_);

      NodeList_add_str(g_, expr_els_, &str_plus);
      NodeList_add(expr_els_, expr_node_l_);
      NodeList_add(expr_els_, expr_node_r_);

      return Node_new_list(g_, expr_els_);
    else

      p_str(Token_get_val(t_));
      panic(380);
    end

  end
end

def parse_expr(g_)
  var t_left_;
  var n;
  var expr_node_l_;

  t_left_ = peek(g_, 0);

  case
  when (Token_kind_eq(t_left_, TOKEN_KIND__INT()))
    inc_token_index(g_);

    n = parse_int(Token_get_val(t_left_));
    expr_node_l_ = Node_new_int(g_, n);

    return _parse_expr_right(g_, expr_node_l_);

  when (Token_kind_eq(t_left_, TOKEN_KIND__IDENT()))
    inc_token_index(g_);

    expr_node_l_ = Node_new_str(g_, Token_get_val(t_left_));

    return _parse_expr_right(g_, expr_node_l_);

  else
    Json_print(Token_to_plain(g_, t_left_));
    panic(433); # not yet impl
  end
end

def parse_set(g_)
  var stmt_;
  var [4]str_set;
  var t_;
  var var_name_;
  var expr_node_;

  str_set_set(&str_set);

  consume_kw(g_, &str_set);

  t_ = peek(g_, 0);
  inc_token_index(g_);
  var_name_ = Token_get_val(t_);

  consume_sym_equal(g_); # =

  expr_node_ = parse_expr(g_);

  consume_sym_semicolon(g_); # ;

  stmt_ = NodeList_new(g_);

  NodeList_add_str(g_, stmt_, &str_set);

  NodeList_add_str(g_, stmt_, var_name_);

  NodeList_add(stmt_, expr_node_);

  return stmt_;
end

def parse_funcall(g_)
  var t_;
  var fn_name_;
  var funcall_;
  var args_;

  t_ = peek(g_, 0);
  inc_token_index(g_);
  fn_name_ = Token_get_val(t_);

  consume_sym_paren_l(g_); # (
  args_ = parse_args(g_);
  consume_sym_paren_r(g_); # )

  funcall_ = NodeList_new(g_);
  NodeList_add_str(g_, funcall_, fn_name_);

  NodeList_add_all(funcall_, args_);

  return funcall_;
end

def parse_call(g_)
  var stmt_;
  var [5]str_call;
  var funcall_;

  str_set_call(&str_call);

  stmt_ = NodeList_new(g_);

  consume_kw(g_, &str_call);
  NodeList_add_str(g_, stmt_, &str_call);

  funcall_ = parse_funcall(g_);
  NodeList_add_all(stmt_, funcall_);

  consume_sym_semicolon(g_); # ;

  return stmt_;
end

def parse_call_set(g_)
  var [9]str_call_set; str_set_call_set(&str_call_set);
  var funcall_;
  var t_;
  var var_name_;
  var stmt_;

  consume_kw(g_, &str_call_set);

  t_ = peek(g_, 0);
  inc_token_index(g_);
  var_name_ = Token_get_val(t_);

  consume_sym_equal(g_); # =

  funcall_ = parse_funcall(g_);

  consume_sym_semicolon(g_);

  stmt_ = NodeList_new(g_);
  NodeList_add_str(g_, stmt_, &str_call_set);
  NodeList_add_str(g_, stmt_, var_name_);
  NodeList_add_list(g_, stmt_, funcall_);

  return stmt_;
end

def parse_return(g_)
  var expr_;
  var stmt_;
  var [7]str_return;

  str_set_return(&str_return);

  consume_kw(g_, &str_return);

  var expr_ = parse_expr(g_);

  consume_sym_semicolon(g_); # ;

  stmt_ = NodeList_new(g_);
  NodeList_add_str(g_, stmt_, &str_return);
  NodeList_add(stmt_, expr_);

  return stmt_;
end

# TODO _parse_when_clause
# TODO parse_case
# TODO parse_while

def parse_vm_comment(g_)
  var t_;
  var [5]str__cmt;
  var stmt_;

  str_set__cmt(&str__cmt);

  stmt_ = NodeList_new(g_);

  consume_kw(g_, &str__cmt);
  consume_sym_paren_l(g_); # (

  t_ = peek(g_, 0);
  inc_token_index(g_);

  NodeList_add_str(g_, stmt_, &str__cmt);
  NodeList_add_str(g_, stmt_, Token_get_val(t_));

  consume_sym_paren_r(g_); # )
  consume_sym_semicolon(g_); # ;

  return stmt_;
end

def parse_stmt(g_)
  var t_;

  t_ = peek(g_, 0);

  case
  when (str_eq_set(Token_get_val(t_)))
    return parse_set(g_);
  when (str_eq__cmt(Token_get_val(t_)))
    return parse_vm_comment(g_);
  when (str_eq_call(Token_get_val(t_)))
    return parse_call(g_);
  when (str_eq_return(Token_get_val(t_)))
    return parse_return(g_);
  when (str_eq_call_set(Token_get_val(t_)))
    return parse_call_set(g_);
  else
    p_str(Token_get_val(t_));
    panic(421); # parse_stmt
  end
end

# TODO parse_stmts
# TODO parse_top_stmt

def parse_top_stmts(g_)
  var top_stmts_;
  var [10]temp_str;

  top_stmts_ = NodeList_new(g_);

  aset(&temp_str, 0, 116); # t
  aset(&temp_str, 1, 111); # o
  aset(&temp_str, 2, 112); # p
  aset(&temp_str, 3,  95); # _
  aset(&temp_str, 4, 115); # s
  aset(&temp_str, 5, 116); # t
  aset(&temp_str, 6, 109); # m
  aset(&temp_str, 7, 116); # t
  aset(&temp_str, 8, 115); # s
  aset(&temp_str, 9,   0);
  NodeList_add_str(g_, top_stmts_, &temp_str);

  while (__not(is_end(g_)))
    NodeList_add_list(g_, top_stmts_, parse_func(g_));
  end

  return top_stmts_;
end

def parse(g_)
  return parse_top_stmts(g_);
end

def GO_TOKENS() return GO_ALLOC_CURSOR() + GS_ALLOC_CURSOR(); end
def GS_TOKENS() return 50; end

def GO_TOKEN_INDEX() return GO_TOKENS() + GS_TOKENS(); end
def GS_TOKEN_INDEX() return 1; end

def GO_NUM_TOKENS() return GO_TOKEN_INDEX() + GS_TOKEN_INDEX(); end
def GS_NUM_TOKENS() return 1; end

def NUM_TOKENS_MAX()
  return GS_TOKENS();
end

def main()
  var [53]g;
  var [300]input; # INPUT_MAX
  var num_tokens;

  # init globals
  init_alloc_cursor(&g);
  set_token_index(&g, 0);
  assert(0, get_token_index(&g), 183);

  read_stdin_all(&input, INPUT_MAX());
  num_tokens = read_tokens(&g, &input);
  set_num_tokens(&g, num_tokens);

  var ast_ = parse(&g);

  Json_print(ast_);
end
